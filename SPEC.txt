.................................................................
.%%......%%.......%%%%...%%...%%...%%%%.............%%......%%...
.%%......%%......%%..%%..%%%.%%%..%%..%%...........%%%.....%%....
.%%......%%......%%%%%%..%%.%.%%..%%%%%%..%%%%%%....%%....%%%%%..
.%%......%%......%%..%%..%%...%%..%%..%%............%%....%%..%%.
.%%%%%%..%%%%%%..%%..%%..%%...%%..%%..%%..........%%%%%%...%%%%..
.................................................................

LLAMA-16 - LLA Micro Architecture

::: Memory Layout :::

0x0000 - 0x3FFF General Purpose ROM  2048 B
0x4000 - 0xFFDF General Purpose RAM  5112 B
0xDFC0 - 0xFFBF Recommended^ Stack   1024 B
0xFFC0 - 0xFFDF Reserved                4 B
0xFFE0 - 0xFFFF Memory Mapped I/O       4 B

^The entirety of the 6136 bytes from 0x4000 to 0xFFBF are allocated as
 user space. This spec recommends building the stack downwards from
 0xFFBF. This midigates the chances of the stack overflowing into user
 programs and heap memory.

:: Memory Mapped I/O ::

0xFFE0 - 0xFFEF Input  16 bits
0xFFF0 - 0xFFFF Output 16 bits

::: Registers :::

0: A  General Purpose Register
1: B  General Purpose Register
2: C  General Purpose Register
3: D  General Purpose Register
4: IP Instruction Pointer Register
5: SP Stack Pointer Register
6: BP Base Pointer Register
7: F  Flags Register:
        15-7: Unused
        8: HALT
        7: Unused
        6: GREATER
        5: EQUAL
        4: LESS
        3: Unused
        2: NEGATIVE
        1: ZERO
        0: POSITIVE

::: Instructions :::
<operation> <source operand> <destination operand>
0: MV   [imm16/reg/mem], [reg/mem]       -> [reg/mem] = [imm16/reg/mem]
1: LEA  [LABEL], [reg]                   -> [reg] = [mem of LABEL]
2: PUSH [imm16/reg/mem]                  -> [SP--] = [imm16/reg/mem]
3: POP  [reg/mem]                        -> reg = [SP++]
4: ADD  [imm16/reg/mem], [reg/mem]       -> [reg/mem] = [rem/mem] + [imm16/reg/mem]
5: SUB  [imm16/reg/mem], [reg/mem]       -> [reg/mem] = [reg/mem] - [imm16/reg/mem]
6: INC  [reg/mem]                        -> [reg/mem] = [reg/mem]++
7: DEC  [reg/mem]                        -> [reg/mem] = [reg/mem]++
8: AND  [imm16/reg/mem], [reg/mem]       -> [reg/mem] = [reg/mem] & [imm16/reg/mem]
9: OR   [imm16/reg/mem], [reg/mem]       -> [reg/mem] = [reg/mem] | [imm16/reg/mem]
A: NOT  [imm16/reg/mem], [reg/mem]       -> [reg/mem] = ~([reg/mem] & [imm16/reg/mem])
B: CMP* [imm16/reg/mem], [reg/mem]       -> f = compare reg, [imm16/reg/mem]
C: CALL [LABEL]                          -> [SP--] = IP; IP = [mem of LABEL]
D: JNZ  [LABEL]                          -> IP = [mem of LABEL/reg/mem] if f != zero
E: RET                                   -> IP = [SP++]
F: HLT

[X] Brackets are used to denote a memory address stored at X
#imm16 Pound sign is used to denote an immediate value
a,b,c,d Values in registers are denoted with alpha a-d where alpha is writable register

:: Instruction Layout ::
<operation> <extra> <source operand type> <destination operand type>

immediate references are encoded as 14->0xE->0b1110
memory address references are encoded as 15->0xF->0b1111
registers are encoded by there alpha order. i.e. a is 0, b is 2, etc

llama:
  mv #3, a ;mv immediate number 3 into register a
binary:
  0000 0000 1110 0000 -> next 2 bytes are immediate value of 3
  0    0    e    0
  mv        imm  a  

::: Directives :::
.data
  Used to define numbers. Legal numbers are positive and negative integers.
  Ex:
    .data +7, -14, 14, 9
.string
  Used to define a single string. Legal strings are enclosed within quotes " ".
  Ex:
    .string "Hello World"

::: Labels :::
Labels are conventionally in all caps. Labels are technically optional. They precede
any operation name and operands.
Ex:
  <label name>: <operation> <source operand> <destination operand>
  <label name>: <operation> <operand>
  <label name>: <operation>
All the above are valid given the opcode is valid.
